#include <bits/stdc++.h>

using namespace std;
//????

template<class T>
class Node
{
protected:
    //???????? ?????????? Node N; N.data = 10 ??????? ??????
    T data;

    //?? ????? ??????? Node, ?? ????? ????? ??????? ?????????
    Node* left;
    Node* right;
    Node* parent;

    //??????????, ??????????? ??? ??????????? ??????? ??????
    int height;
public:
    //????????? ????? ?????????? ? ???????
    virtual void setData(T d) { data = d; }
    virtual T getData() { return data; }
    int getHeight() { return height; }

    virtual Node* getLeft() { return left; }
    virtual Node* getRight() { return right; }
    virtual Node* getParent() { return parent; }

    virtual void setLeft(Node* N) { left = N; }
    virtual void setRight(Node* N) { right = N; }
    virtual void setParent(Node* N) { parent = N; }

    //???????????. ????????????? ????????? ???????? ??? ??????????
    Node<T>(T n)
    {
        data = n;
        left = right = parent = NULL;
        height = 1;
    }

    Node<T>()
    {
        left = NULL;
        right = NULL;
        parent = NULL;
        data = 0;
        height = 1;
    }


    virtual void print()
    {
        cout << "\n" << data;
    }

    virtual void setHeight(int h)
    {
        height = h;
    }

    template<class T1> friend ostream& operator<< (ostream& stream, Node<T1>& N);
};

template<class T1>
ostream& operator<< (ostream& stream, Node<T1>& N)
{
    stream << "\nNode data: " << N.data << ", height: " << N.height;
    return stream;
}
template<class T>
void print(Node<T>* N) { cout << "\n" << N->getData(); }


template<class T>
class Tree
{
protected:
    //?????? - ??? ?????????? ??? ???????? ????? ??????
    Node<T>* root;

    virtual Node<T>* push(Node<T>* N)
    {
        return push(N, root);
    }

    virtual Node<T>* push(Node<T>* N, Node<T>* Current)
    {
        //?? ??????? ??????????? ????
        if (N == NULL) return NULL;

        //?????? ?????? - ????????? ? ??????
        if (root == NULL)
        {
            root = N;
            return N;;
        }

        if (Current->getData() > N->getData())
        {
            //???? ?????
            if (Current->getLeft() != NULL) return push(N, Current->getLeft());
            else { (Current->setLeft(N)); N->setParent(Current); }
        }
        if (Current->getData() < N->getData())
        {
            //???? ??????
            if (Current->getRight() != NULL) return push(N, Current->getRight());
            else { Current->setRight(N); N->setParent(Current);}
        }
        if (Current->getData() == N->getData()) {

        }
            //????? ??????????
            ;
        //??????? ??????????? ????
        return  N;
    }

public:
    //?????? ? ????????? ????????
    virtual Node<T>* getRoot() { return root; }

    //??????????? ??????: ? ?????? ???????? ?????? ?? ?????? ???? ???, ?????? ??????? ? ??????
    Tree<T>() { root = NULL; }

    //??????? ?????????? ???? ? ??????

    //???????????? ??????? ?????????? ????. ????????? ?????????? (??????????? ?????? ?????????,
    //???? ????? ????????? ????), ?? ???????? ???? ???? - ?????????? ? ????? ??? ?????? ?????????

    //??????? ??? ?????????? ?????. ?????? ????? ???? ? ????? ??????? ? ???????? ?????? ??????? ?????????? ? ??????

    //???????? ????
    virtual void Remove(Node<T>* N)
    { }

    //????? ???????? ? ????????? ? ??????
    virtual Node<T>* Min(Node<T>* Current=NULL)
    {
        if (Current == NULL) {
            Current = root;
        }
        if (root == NULL) return NULL;
        while (Current->getLeft()) {Current = Current->getLeft();}
        return Current;
    }

    virtual Node<T>* Max(Node<T>* Current = NULL)
    {

    }

    //????? ???? ? ??????
    virtual Node<T>* Find(T data)
    {
        if (root == NULL) return NULL;
        return Find_R(data, root);
    }

    //????? ???? ? ??????. ?????? ???????? - ? ????? ????????? ??????, ?????? - ??? ??????
    virtual Node<T>* Find_R(T data, Node<T>* Current)
    {
        //???? ????????
        if (Current == NULL || Current->getData() == data) return Current;
        //??????????? ?????
        if (Current->getData() > data) return Find_R(data, Current->getLeft());
        if (Current->getData() < data) return Find_R(data, Current->getRight());
    }

    //??? ?????? ??????
    virtual void PreOrder(Node<T>* N, void (*f)(Node<T>*))
    {
        if (N != NULL)
            f(N);
        if (N != NULL && N->getLeft() != NULL)
            PreOrder(N->getLeft(), f);
        if (N != NULL && N->getRight() != NULL)
            PreOrder(N->getRight(), f);
    }

    //InOrder-????? ???? ??????????????? ??????????????????
    virtual void InOrder(Node<T>* N, void (*f)(Node<T>*))
    {
        if (N != NULL && N->getLeft() != NULL)
            InOrder(N->getLeft(), f);
        if (N != NULL)
            f(N);
        if (N != NULL && N->getRight() != NULL)
            InOrder(N->getRight(), f);
    }

    virtual void PostOrder(Node<T>* N, void (*f)(Node<T>*))
    {
        if (N != NULL && N->getLeft() != NULL)
            PostOrder(N->getLeft(), f);
        if (N != NULL && N->getRight() != NULL)
            PostOrder(N->getRight(), f);
        if (N != NULL)
            f(N);
    }

    virtual void push(int n)
    {
        Node<T>* N = new Node<T>(n);
        push(N);
    }
};

//????? ???????? ?? ??????
template<typename ValueType>
class TreeIterator : public std::iterator<std::input_iterator_tag, ValueType>
{
private:
    Node<ValueType>* ptr;
public:
    TreeIterator() { ptr = NULL; }
    TreeIterator(Tree<ValueType>* t, Node<ValueType>* p) {  }
    TreeIterator(const TreeIterator& it) {  }

    TreeIterator& operator=(const TreeIterator& it) {  }
    TreeIterator& operator=(Node<ValueType>* p) {  }

    bool operator!=(TreeIterator const& other) const {  }
    bool operator==(TreeIterator const& other) const {  }
    Node<ValueType>& operator*(){}
    TreeIterator& operator++()
    {

    }
    TreeIterator& operator++(int v)
    {

    }
};

//????? ??????????? ?????? ??????
template<class T>
class IteratedTree : public Tree<T>
{
public:
    IteratedTree<T>() : Tree<T>() {}

    TreeIterator<T> iterator;

    TreeIterator<T> begin() {  }
    TreeIterator<T> end() {  }
};



int main()
{
    Tree<double> T;
    int arr[15];
    int i = 0;
    for (i = 0; i < 15; i++) arr[i] = (int)(100 * cos(15 * double(i)));
    for (i = 0; i < 15; i++) T.push(arr[i]);

//    Node<double>* M = T.Min();
//    cout << "\nMin = " << M->getData() << "\tFind " << arr[3] << ": " << T.Find(arr[3]);
    cout << T.Find(-95) << endl;

    void (*f_ptr)(Node<double>*); f_ptr = print;
    /*cout << "\n-----\nPreorder:";
    T.PreOrder(T.getRoot(), f_ptr);*/
    cout << "\n-----\nInorder:";
    T.InOrder(T.getRoot(), f_ptr);
    cout << "\n-----\nPostorder:";
    T.PostOrder(T.getRoot(), f_ptr);
    cout << endl;
//    cout << "\nIterators:\n";
//    T.iterator = T.begin();
//    while (T.iterator != T.end())
//    {
//        cout << *T.iterator << " ";
//        T.iterator++;
//    }
//    cout << *T.iterator << " ";
    return 0;
}
